# 5주차. 트리, 유니온 파인드, 최소 스패닝 트리,  알고리즘
## 트리
### 정의

![3](https://github.com/kanghuiseon/algorithmStudy/blob/master/Rare5_Tree/Resource/3.png)

* 트리는 하나의 루트 노드를 가지고 있고, 이 루트 노드는 자식 노드를 0개 이상 가지고 있다.

* 이 자식 노드도 0개 이상의 자식 노드를 가진다.

* 이 노드들은 간선(엣지)로 연결되어 있는데 중요한점! 은 트리는 **사이클이 있으면 안된다.** (self loop 도 없음!)

* 모든 자식 노드는 한 개의 부모 노드만을 가진다.

### 종류
이진 트리,  이진 탐색 트리, AVL 트리, 이진 힙(Max heap, Min heap) 등이 있다.

* 이진 트리
각 노드가 두 개의 자식 노드만을 가지는 트리

* 이진 탐색 트리
모든 노드가 다음의 특징을 가지는 트리.

각 노드의 왼쪽 서브 트리들은 부모 노드의 값보다 작거나 같은 값을 가지는 노드로만 이루어져 있다.

각 노드의 오른쪽 서브 트리들은 부모 노드의 값보다 큰 값을 가지는 노드로만 이루어져 있다.

* AVL 트리
균형 잡힌 트리라고 해서 자식 노드와 부모 노드의 높이 차는 최소 1이어야 한다.

* Max heap, Min heap
완전 이진 트리로 모든 레벨의 노드가 채워져 있어야 하고 마지막 레벨은 왼쪽 부터 채운다.

이진 힙은 부모 노드 값이 자식 노드 값보다 크면 Max heap, 작으면 Min heap이다.




## 유니온 파인드
Disjoint-set이라고도 한다. 어떤 두 개의 노드를 같은 집합에 묶고 두 개의 노드가 같은 집합에 있는지 확인하는 알고리즘이다.

1. find
```cpp
int find(int x){
    if(parents[x] == x){
        return x;
    }
    else{
        return parents[x] = find(parents[x]);
    }
}
```
2. Union
```cpp
void union_find(int x, int y){
    x = find(x);
    y = find(y);
    if(x != y){
        parents[y] = x;
    }
}
```
3. check
```cpp
bool checkParents(int x, int y){
    x = find(x);
    y = find(y);
    if(x == y){
        return true;
    }
    return false;
}
```



## 스패닝 트리란 뭘까!
그래프 내의 모든 정점을 포함하고 있는 트리! 

왜 트리라고 하냐면 사이클을 포함하고 있지 않기 때문이다.

그래프의 일부 간선을 이용해서 만든 것이여서 항상 그래프의 부분집합이 된다.


## 그렇다면 최소 스패닝 트리란 뭘까!
최소 스패닝 트리 줄여서 MST라고 한다. 이것은 Spanning tree의 한 종류로, 간선의 가중치의 합이 최소인 트리를 말한다.

MST를 구현하는 방법에는 두 가지 알고리즘이 있다.




## 1. 크루스칼(Kruskal) 알고리즘
크루스칼 알고리즘은 현재 가장 비용이 작은 간선을 연속으로 택한다. 근데 사이클이 생길 수도 있기 때문에 사이클 체크를 계속 해줘야 한다.

### 구현
1. 그래프에 대한 정보를 가지고 있을 테니 이것을 가중치에 대한 오름차순으로 정렬한다. 
2. 가장 앞에서부터 사이클이 생기지 않는 선에서 가중치가 가장 작은 간선을 선택한다.

### 사이클 판단
사이클의 존재 여부는 유니온 파인드로 구현할 수 있다.

최종 부모를 가지는 배열을 만들고 각 인덱스에 해당하는 값은 자기 자신의 부모이다. 

만약 연결하려고 하는 두 개의 노드의 부모가 같다면 연결하지 않도록 한다. (이게 사이클이 있다는 말임)

### 시간 복잡도
사이클 판단에 유니온 파인드를 사용하면 O(1)이므로 정렬하는 시간만 체크하면 된다.

간선 개수만큼 정렬하고(E), 뽑아내므로(logE) **ElogE** 이다.


## 2. 프림(Prim) 알고리즘
프림 알고리즘은 크루스칼과는 다르게 시작 노드을 가져야 한다.(아무거나!) 여기에 다른 노드을 추가하면서 트리를 점점 확장시키는 방식이다.

(간선을 추가시키는 크루스칼과는 반대!)

노드를 확장시키는 기준은 현재 노드에서 갈 수 있는 모든 노드 중에서 비용이 가장 작은 간선을 가진 노드를 선택한다. (이미 선택한 노드는 선택못함!)

### 구현
1. 임의의 노드 선택, 노드 집합에 추가
2. 선택된 노드와 연결된 간선들을 간선 리스트에 추가
3. 간선 리스트 중에서 최소 가중치를 가지는 간선부터 본다.
4. 이미 연결된 노드가 노드 집합에 있다면 패쓰, 없다면 해당 간선을 MST에 추가
5. 추출한 간선은 간선 리스트에서 제거
6. 이 과정을 노드 집합에 모든 노드가 추가될 때까지 반복

![0](https://github.com/kanghuiseon/algorithmStudy/blob/master/Rare5_Tree/Resource/0.png)

![1](https://github.com/kanghuiseon/algorithmStudy/blob/master/Rare5_Tree/Resource/1.png)

![2](https://github.com/kanghuiseon/algorithmStudy/blob/master/Rare5_Tree/Resource/2.png)

### 시간 복잡도
1. **인접 행렬** : O(V^2)
이중 포문으로 값을 찾으니까 V^2
2. **인접 리스트** : O((V+E)logV) = O(ElogV)
최소 힙(priority_queue)을 사용해서 트리에 포함시킬 간선을 찾으면 ElogV가 나올 수 있다.

인접리스트에서 V+E, priority_queue로 간선 빼내기 logV
















