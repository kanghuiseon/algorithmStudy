## [1068 트리](./1068_트리.py)
재귀로 par 를 타고 올라가면서 지워진 노드이면 처리.  
child 개수 세줄때도 지워진노드면 추가해주지 않는다. -> 단일노드 문제 해결.  

## [1197 최소스패닝트리](./1197_최소스패닝트리.py)
가장 기본적인 형태의 최소 스패닝 트리.  
크루스칼로 풀어줌.  

## [1774 우주신과의교감](./1774_우주신과의교감.py)
좌표값을 이용해 각 위치별 거리를 구해준 후 MST 구현.  

## [1717 집합의표현](./1717_집합의표현.py)
가장 기본의 union-find 문제.  

## [1976 여행가자](./1976_여행가자.py)
i,j 가 1인 애들 merge 후 계획 순서대로 연결되어있는지 여부만 확인.  

## [2263 트리의순회](./2263_트리의순회.py)
postorder 의 맨 뒤에 값이 root.  
inorder는 root 기준으로 left,right로 나뉨.  
이 2가지 사실을 이용해서 재귀적으로 풀어줌.  
index를 넘겨줄 때 root 를 포함하지 않도록 넘겨주어야 한다.  

## [4195 친구네트워크](./4195_친구네트워크.py)
par 배열을 par,child 리스트로 만들어주면됨.  
input 이 str임으로 dict 로 구현.  

## [5052 전화번호목록](./5052_전화번호목록.py)
python 의 in 을 사용해서 구현하면 시간초과.  
trie 구현해서 풀어줌. word 찾고도 trie 길이가 남아있으면 false 리턴.  

## [14621 나만안되는연애](./14621_나만안되는연애.py)
남자-여자 로 연결해야되기 때문에 성별만 확인해서 연결하면됨.  
못하는 경우 -1 출력.. 문제 잘 읽고푸세요.  

## [20040 사이클게임](./20040_사이클게임.py)
union-find 로 풀면됨. -> 사이클 생기면 생긴 위치만 기억하면됨.  

## [1944 복제로봇](./1944_복제로봇.py)
bfs로 돌면서 문제를 푸는데 복제될때 해당 친구의 cost 와 열쇠위치(번호) 를 기억  
이후에 cost 기준으로 정렬 후 열쇠횟수만큼 MST.  -> 이상함을 깨닫고 아래로 바꿈.    
복제될때 cost 초기화 + 로봇 번호랑 열쇠번호 구분 어떻게 할지 생각.  
결론 : 각 위치별 bfs 돌아서 연결하면 되는 거였다!!  
