## [12865 평범한배낭](./12865_평범한배낭.py)
`dp[N][K]` == N개 물건, K무게 일때 최대 가치.  
무게를 보면서 추가할 수 있는 경우 -> 그전의 가치와 비교 후 크면 추가.  

## [1520 내리막길](./1520_내리막길.py)
`dfs` 에 `dp` 넣어서 풀었다.  
`dp[x][y]` == 해당 위치에서 `board[N][M]` 까지 내리막길로만 갈 수 있는 경우의 수.  

## [9251 LCS](./9251_LCS.py)
`dp[i][j]` == i,j번째까지의 LCS 길이.  
`sys.stdin.readline` 의 경우 `\n` 을 포함해서 입력을 받기 때문에 `strip()` 함수로 제거해줘야 필요로하는 문자열부분만 얻을 수 있다.  

## [9252 LCS2](./9252_LCS2.py)
`9251 LCS` 문제에서 구한 `dp` 를 이용해 역순으로 값을 구해나가면 된다.  

## [10942 팰린드롬](./10942_팰린드롬.py)
`dp[st][end]` == st,end까지 펠린드롬 여부.  
짝수길이,홀수길이 일때 다르기 때문에 두개로 나눠서 펠린드롬 구해서 풀어줌.  
한번에 구하는 방법이 있나 보니까 `Manacher` 알고리즘 존재.  `O(N)` 으로 판단 가능.  (https://www.crocus.co.kr/1076) 보고 공부하고 풀어보자. 

## [11054 가장긴바이토닉부분수열](./11054_가장긴바이토닉부분수열.py)
정방향,역방향의 dp배열을 만들어서 풀어주면 된다.  
`dpfor[i][j]` == 정방향 증가수열 개수.  
`dpback[i][j]` == 역방향 증가수열 개수.  

## [1005 ACMCraft](./1005_ACMCraft.py)
순서에 따른 문제로 `위상정렬` 공부 후 풀었다. -> 조건 충족 시 다음 진행.  
최단 거리로 이동하기 때문에 `dp` 갱신 시 `max` 값으로 해주면 된다.  
`dp[N]` == N번째 건물 지을 때 최소 시간.  

## [1915 가장큰정사각형](./1915_가장큰정사각형.py)
`dp[i][j]` == 정사각형의 한 변의 길이.  
`[i-1][j-1]`,`[i-1][j]`,`[i][j-1]` 의 제일 작은 값 + 1 로 해주면 정사각형이 되는 경우에만 길이가 늘어남.  


 