# 8주차. DP + 구현
## 1958. LCS3 (골드 3)
문자열 세 개를 보니까 dp를 삼중배열로 만들었다.
```cpp
for(int i=0; i<s1.size(); i++){
    for(int j=0; j<s2.size(); j++){
        for(int k=0; k<s3.size(); k++){
            if(s1[i] == s2[j] && s2[j] == s3[k]){
                dp[i+1][j+1][k+1] = dp[i][j][k]+1;
            }else{
                dp[i+1][j+1][k+1] = max(dp[i][j+1][k+1], max(dp[i+1][j][k+1], dp[i+1][j+1][k]));
            }
        }
    }
}
```
세 개의 알파벳이 같으면 대각선 왼쪽위의값에 1을 더한 값을 현재에 저장하고, 

그렇지 않으면 그냥 세 개 알파벳 중에서 가장 큰 값을 현재에 저장한다.


## 2225. 합분해 (골드 5)
dp[i][j] : i개로 숫자 j를 만드는 방법의 수

예를 들어 dp[6][10]은 6개의 숫자로 10을 만드는 방법의 경우의 수이다.

dp[5][0]의 경우는 00000밖에 없다. 여기에 10을 더하면 6개로 10을 만드는 방법이다.

dp[5][1]의 경우, 00001, 00010, 00100, 01000, 10000이 있다. 각 숫자에 9를 더하기만 하면 6개로 10을 만드는 방법이 된다.

이렇게 쭉쭉쭉쭉 하다가 dp[5][10]의 경우의수에서 각각의 수에 0을 더하면 6개로 10을 만드는 경우의 수가 나온다.

위의 경우의 수를 모두 더하고 십억으로 나눈 값을 dp[i][j]에 넣는다.

## 14728. 벼락치기 (골드 5)
기본적인 냅색 문제!

## 21923. 곡예 비행 (골드 4)
가장 왼쪽 아래에서부터 bfs를 돌리고, 가장 오른쪽 아래에서부터 bfs를 돌려서 scoreUp, scoreDown값을 채운다.

그리고 나서 scoreUp[I][j] + scoreDown[I][j]값이 가장 큰 값을 출력하면 된다.
